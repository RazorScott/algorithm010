学习笔记
二叉树
二叉树的操作通常都需要递归来做， 比如二叉树的前中后序遍历，如果不通过递归，也可以用stack模拟.

堆
堆必须是完全二叉树，而且必须满足父节点大于(或小于)子节点。底层可以通过数组实现，使用数组可以节省空间，不需要存储指向子节点的指针。完全二叉树可以通过下标计算得出结点相互关系，数组可以随机访问，方便了结点的访问。  某个结点i的左右子树分别为2*i+1 和 2*i+2
插入和删除操作都是在队尾进行，这样保证仍然是完全二叉树。插入先插到队尾，然后popup，删除堆顶先与最后一个结点互换，然后popdown。堆的实现有多种，二叉堆，斐波那契堆等，斐波那契堆可以将插入删除也做到O(1)
堆的应用，top K 问题，先建大小为K的小顶堆，每次有新数据就与堆顶比较，更新复杂度为lgK

图
图可以看做是有环的树，无向图也可以看做是双向图，另外图的边还可以加权信息. 图的存储可以用邻接表（二维数组）或邻接矩阵（一维链表数组. 在遍历图时要注意加visited, 因为图有可能是有环的
图的应用很多，现实中的很多场景都可以抽象成图，比如最短路，拓扑排序，网络流等等。

hashmap in C++
C++里面的hashmap是unordered_map。实现：https://gcc.gnu.org/onlinedocs/gcc-4.7.0/libstdc++/api/a01538_source.html
内部也是hash表实现，当使用自定义类型为key时，自定义类型需要实现hash方法才能使用unordered_map

hash sort
堆排序有两个步骤，建堆和排序。建堆就是将数组堆化，即使数组表现为一个完全二叉树且父节点大于（从大到小排序就建小顶堆）子节点。而排序的过程就是调整结点位置,每次将堆顶的位置挪到最后(第一次是数组的最后一位，然后每次将最后位置向前一位)，然后调整堆，相当于每次删除堆顶。当最后位置到达1时，结束。
堆排序的思想是通过堆的一些性质来达到排序的目的，堆底层是通过数组实现，堆的一些操作也是在数组上进行，不需要额外的空间，可以做到原地排序。
